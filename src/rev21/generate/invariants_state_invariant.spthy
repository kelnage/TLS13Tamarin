

theory TLS_13_invariants
begin

builtins: diffie-hellman, hashing, symmetric-encryption, signing

section{* TLS 1.3 *}

/*
 * Protocol:    TLS 1.3 Handshake and Record Protocols
 * Modeler:     Cas Cremers, Marko Horvat, Sam Scott, Thyla van der Merwe
 * Year:        2016
 * Source:      http://tlswg.github.io/tls13-spec/
 *
 * Status:  in progress....
 */

// Hash declarations

functions: Expand/3, Extract/2, hmac/1, mac/1, mask/2, unmask/2

equations: unmask(mask(x, y), y) = x, unmask(mask(x, y), x) = y

/* AXIOMS */

/* Explicit equality checking */
axiom Eq_check_succeed: "All x y #i. Eq(x,y) @ i ==> x = y"
axiom Neq_check_succeed: "All x y #i. Neq(x,y) @ i ==> not (x = y)"

/* Generate one long-term key per actor */
axiom one_ltk:
  "All A x y #i #j.
    GenLtk(A, x)@i & GenLtk(A, y)@j ==> #i = #j"

axiom one_role_per_actor:
    "All actor tid tid2 role role2 #i #j. Start(tid, actor, role)@i & Start(tid2, actor, role2)@j
        ==> role = role2"

// crypto.m4i imports

// msgs.m4i imports

// state.m4i imports

/* ------- Public key infrastructure -------*/

/*
  Register PK
  ----------------
  
  Generates a long-term key for a party.

  Premises:
    Fr(~ltkA) - a fresh value for the key itself

  Actions:
    GenLtk($A, ~ltkA) - party $A has generated a long-term key

  Conclusions:
    !Ltk($A, ~ltkA) - binds the long-term key to the party $A
    !Pk($A, pk(~ltkA)) - models the distribution of the public key by some PKI
    Out(pk(~ltkA)) - outputs the public key so the adversary has knowledge
*/
rule Register_pk:
  [ Fr(~ltkA) ]--[ GenLtk($A, ~ltkA), HonestUse(~ltkA)
  ]->
  [ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]

/*
  Reveal Ltk
  ----------------
  
  The adversarial capability to reveal long-term keys of parties.

  Premises:
    !Ltk($A, ~ltkA) - the long-term key to compromise

  Actions:
    RevLtk($A) - adversary has revealed the key of $A.

  Conclusions:
    Out(~ltkA) - provides the adversary with the long-term key
*/
rule Reveal_Ltk:
  [ !Ltk($A, ~ltkA) ] --[ RevLtk($A) ]-> [ Out(~ltkA) ]

rule client_hello:
let
    // Initialise state variables to zero.
     messages = '0'
res_psk = '0'
nc = '0'
ns = '0'
g = '0'
sg = '0'
hrr = '0'
x = '0'
y = '0'
gx = '0'
gy = '0'
gxy = '0'
psk_ke_mode = 'na'
psk_id = '0'
edi = '0'
es = '0'
hs = '0'
ms = '0'
cats = '0'
sats = '0'
hs_keyc = '0'
hs_keys = '0'
auth_status = <'0', '0'>
ems = '0'
rms = '0'
cert_req = '0'

    // Abstract client identity - does not currently correspond to
    // anything concrete
    C = $C

    // Server identity - can be interpreted as the hostname
    S = $S

    // Client nonce
    nc = ~nc

    // We reuse the client nonce to be a thread identifier
    tid = nc

    // Group, DH exponent, key share
    g1 = $g1
    g2 = $g2
    sg = <g1, g2>
    client_sg = <g1, g2>
    g = g1
    x = ~x
    gx = g^x

    messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >>
    es = Extract(res_psk, '0')
in
    [ Fr(nc),
      Fr(x)
    ]
  --[ C0(tid),
      Start(tid, C, 'client'),
      RIdentity(tid, C, 'client', <C>),
      Neq(g1, g2),
      DH(tid, C, x),
      HonestUse(~x),
      HonestUse(gx)
    ]->
    [
      State(tid,'C1',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      DHExp(x, tid, C),
    // Write the ClientHelloMsg onto the wire *presumably* with destination S
      Out(<'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >)
    ]

rule recv_hello_retry_request:
let
    g1 = $g1
    g2 = $g2
    p_sg = <g1, g2>
    p_g = g1
    p_hrr = '0'
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    hrr = 'hrr'
    new_g = g2
    g = g2
    client_sg = <g1, g2>

    C = $C
    S = $S

    new_x = ~new_x
    x = new_x
    gx = g^x

    // PSK after HRR has its own rule (see recv_hello_retry_request_psk)
    psk_ke_mode = 'na'
    auth_status = <'0', '0'>

    messages = <messages, <'6',    '0x0303',    <<'40',new_g>> >>
    messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >>
    es = Extract(res_psk, '0')
in
    [ State(tid,'C1',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      Fr(new_x),
      In(<'6',    '0x0303',    <<'40',new_g>> >),
      DHExp(p_x, tid, C)
    ]
  --[ C1_retry(tid),
      Neq(g1, g2),
      Instance(tid, C, 'client'),
      DeleteDH(tid, C, p_x),
      DH(tid, C, x)
    ]->
    [ Out(<'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >),
      DHExp(x, tid, C),
      State(tid,'C1',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_server_hello:
let
    p_g = $g
    p_x = ~x

    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    ns = new_ns
    gy = new_gy

    C = $C
    S = $S

    // equivalent to checking gy in <$g>
    gy = g^new_y

    // Derive the shared secret
    gxy = gy^x

    // Received a basic server hello - abandon PSK mode (if attempted)
    psk_ke_mode = 'na'
    auth_status = <'0', '0'>

    messages = <messages, <'2',  '0x0303',  ns,  $cipher_suite,  <<'13',$sig_algs>,<'40',g,gy>> >>
in
    [ State(tid,'C1',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      In(<'2',  '0x0303',  ns,  $cipher_suite,  <<'13',$sig_algs>,<'40',g,gy>> >)
    ]
  --[ C1(tid),
      Instance(tid, C, 'client'),
      Neq(gy, g),
      Neq(gxy, g),
      DHChal(g, x, new_y, gx, gy, gxy),
      RNonces(tid, C, 'client', <nc,ns>)
    ]->
    [
      State(tid,'C2a',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule client_gen_keys:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    hs = Extract(gxy, es)
    ms = Extract('0', hs)

    hs_keyc = Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'kshe_wk', '0'>, '32')
    hs_keys = Expand(Expand(hs, <'serverhts', <h(messages)>>, '32'), <'kshe_wk', '0'>, '32')

in
    [ State(tid,'C2a',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      DHExp(x, tid, C)
    ]
  --[ C2a(tid),
      Instance(tid, C, 'client'),
      RMS(tid, C, 'client', <ms>),
      RHS(tid, C, 'client', <hs>),
      DeleteDH(tid, C, x)
    ]->
    [
      State(tid,'C2b',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_encrypted_extensions:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

    messages = <messages, <'8',$exts>>

in
    [ State(tid,'C2b',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      In(senc{<'8',$exts>}hs_keys)
    ]
  --[ C2b(tid),
      Instance(tid, C, 'client')
    ]->
    [ State(tid,'C2c',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_certificate_request:
let
    p_psk_ke_mode ='na'
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

    certificate_request_context = '0' 
    cert_req = '1'
    messages = <messages,  <'13',  certificate_request_context,  $certificate_extensions >>

in
    [ State(tid,'C2c',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      In(senc{ <'13',  certificate_request_context,  $certificate_extensions >}hs_keys)
    ]
  --[ C2c_req(tid),
      Instance(tid, C, 'client')
    ]->
    [ State(tid,'C2d',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule skip_recv_certificate_request:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C
    cert_req = '0'
in
    [ State(tid,'C2c',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req )
    ]
  --[ C2c(tid),
      Instance(tid, C, 'client')
    ]->
    [ State(tid,'C2d',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_server_auth:
let
    p_psk_ke_mode = 'na'
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

    certificate_request_context = '0'
    certificate = pk(~ltkS)
    messages = <messages, <'11',certificate_request_context,certificate>>
    sig_messages = <'server_cv', <h(messages)>>

    messages = <messages, <'15',  signature >>

    exp_verify_data = hmac(Expand(Expand(hs, <'serverhts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>

    cats = Expand(ms, <'clientats', <h(messages)>>, '32')
    sats = Expand(ms, <'serverats', <h(messages)>>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
    ems = Expand(ms, <'ems', <h(messages)>>, '32')

    // auth_status = <cas, sas>
    auth_status = <'0', 'auth'>
in
    [ State(tid,'C2d',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      !Pk(S, pk(~ltkS)),
      In(senc{<'11',certificate_request_context,certificate>, <'15',  signature >, <'20',verify_data>}hs_keys)
    ]
  --[ C2d(tid),
      Instance(tid, C, 'client'),
      Eq(psk_ke_mode, 'na'),
      Eq(verify(signature, sig_messages, pk(~ltkS)), true),
      Eq(verify_data, exp_verify_data),
      RMode(tid, C, 'client', <psk_ke_mode>),
      CIdentity(tid, C, 'client', <<S,auth_status>>),
      CHS(tid, C, 'client', <hs>),
      CTranscript(tid, C, 'client', <messages>),
      CNonces(tid, C, 'client', <nc,ns>)
    ]->
    [ State(tid,'C3',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys)
    ]

rule client_auth:
let
    // If certificate was requested, cannot ignore
    p_cert_req = '0'
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

    verify_data = hmac(Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>

    rms = Expand(ms, <'rms', <h(messages)>>, '32')
    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in

    [ State(tid,'C3',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req )
    ]
  --[ C3(tid),
      Instance(tid, C, 'client'),
      RTranscript(tid, C, 'client', <messages>),
      RHSMS(tid, C, 'client', <hs,ms>),
      RRMS(tid, C, 'client', <S,rms,messages>),
      RMode(tid, C, 'client', <psk_ke_mode>),
      SessionKey(tid, C, S, auth_status, <app_keyc, app_keys>)
    ]->
    [ State(tid,'C4',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      Out(senc{<'20',verify_data>}hs_keyc),
      SendStream(tid, C, S, auth_status, app_keyc)
    ]

rule client_auth_cert:
let
    p_cert_req = '1'
    p_psk_ke_mode = 'na'
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

    certificate_request_context = '0' 
    certificate = pk(~ltkC)
    messages = <p_messages, <'11',certificate_request_context,certificate>>

    signature = sign{<'client_cv', <h(messages)>>}~ltkC
    messages = <messages, <'15',  signature >>

    verify_data = hmac(Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))
    messages = <messages, <'20',verify_data>>

    rms = Expand(ms, <'rms', <h(messages)>>, '32')

    // zeroes cert_req after it has been used
    cert_req = '0'

    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')

    auth_status = <'auth', 'auth'>
in

    [ State(tid,'C3',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      RecvStream(tid, C, S, p_auth_status, app_keys),
      !Ltk(C, ~ltkC)
    ]
  --[ C3_cert(tid),
      Instance(tid, C, 'client'),
      UseLtk(~ltkC, signature),
      RHSMS(tid, C, 'client', <hs,ms>),
      RTranscript(tid, C, 'client', <messages>),
      RRMS(tid, C, 'client', <S,rms,messages>),
      RMode(tid, C, 'client', <psk_ke_mode>),
      SessionKey(tid, C, S, auth_status, <app_keyc, app_keys>)
    ]->
    [ State(tid,'C4',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      Out(senc{<'11',certificate_request_context,certificate>, <'15',  signature >, <'20',verify_data>}hs_keyc),
      SendStream(tid, C, S, auth_status, app_keyc),
      RecvStream(tid, C, S, auth_status, app_keys)
    ]

rule start_server:
let
    C = $C
    S = $S

    // Initialises all variables to zero.
     messages = '0'
res_psk = '0'
nc = '0'
ns = '0'
g = '0'
sg = '0'
hrr = '0'
x = '0'
y = '0'
gx = '0'
gy = '0'
gxy = '0'
psk_ke_mode = 'na'
psk_id = '0'
edi = '0'
es = '0'
hs = '0'
ms = '0'
cats = '0'
sats = '0'
hs_keyc = '0'
hs_keys = '0'
auth_status = <'0', '0'>
ems = '0'
rms = '0'
cert_req = '0'

    tid = ~tid
    sg = $g
in
    [ Fr(tid)
    ]
  --[ Start(tid, S, 'server'),
      RIdentity(tid, S, 'server', <S>)
    ]->
    [
      State(tid,'S0',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

/*
    Server receives vanilla ClientHello
*/

rule recv_client_hello:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    psk_ke_mode = 'na'
    g1 = $g1
    g2 = $g2
    client_sg = <g1, g2>
    nc = new_nc
    gx = new_gx
    g = $new_g
    gx = g^new_x

    // Abstract client identity - does not currently correspond to
    // anything concrete
    // From the server's perspective: associate with an open socket.
    C = $C

    // Server identity - can be interpreted as the hostname
    S = $S

    // Server nonce
    ns = ~new_ns

    messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >>

    psk_ke_mode = 'na'

in
    [ In(<'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >),
      Fr(ns),
      State(tid,'S0',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req )
    ]
  --[ S0(tid),
      Neq(g1, g2)
    ]->
    [
      State(tid,'S1',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule hello_retry_request:
let
    // Cannot HRR twice in a handshake
    p_hrr = '0'
    p_sg = $p_sg
    // Copies across all values from  p_res_psk, p_messages, p_nc, p_ns, p_g, p_sg, p_hrr, p_x, p_y, p_gx, p_gy, p_gxy, p_psk_ke_mode, p_psk_id, p_edi, p_es, p_hs, p_ms, p_cats, p_sats, p_hs_keyc, p_hs_keys, p_auth_status, p_ems, p_rms, p_cert_req  to  res_psk, messages, nc, ns, g, sg, hrr, x, y, gx, gy, gxy, psk_ke_mode, psk_id, edi, es, hs, ms, cats, sats, hs_keyc, hs_keys, auth_status, ems, rms, cert_req 
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    hrr = 'hrr'
    new_g = sg
    g = sg

    C = $C
    S = $S

    messages = <messages, <'6',    '0x0303',    <<'40',new_g>> >>

in
    [ State(tid,'S1',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req )
    ]
  --[ S1_retry(tid),
      Neq(p_g, sg),
      Instance(tid, S, 'server')
    ]->
    [ Out(<'6',    '0x0303',    <<'40',new_g>> >),
      State(tid,'S0',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

/*
    Server sends basic ServerHello
*/

rule server_hello:
let
    p_g = $p_g
    p_gx = p_g^some_x
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    // Server continuing in normal mode (no PSK mode)
    psk_ke_mode = 'na'
    auth_status = <'0', '0'>

    C = $C
    S = $S

    // Group, DH exponent, key share
    y = ~y
    gy = g^y
    gxy = gx^y

    es = Extract(res_psk, '0')
    messages = <messages, <'2',  '0x0303',  ns,  $cipher_suite,  <<'13',$sig_algs>,<'40',g,gy>> >>
in
    [ State(tid,'S1',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      Fr(y)
    ]
  --[ S1(tid),
      Eq(g, sg),
      Neq(gx, g),
      Neq(gxy, g),
      Instance(tid, S, 'server'),
      RNonces(tid, S, 'server', <nc,ns>),
      DHChal(g, some_x, y, gx, gy, gxy),
      DH(tid, S, y)
    ]->
    [
      State(tid,'S2a',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      DHExp(y, tid, S),
      Out(<'2',  '0x0303',  ns,  $cipher_suite,  <<'13',$sig_algs>,<'40',g,gy>> >)
    ]

rule server_gen_keys:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

    hs = Extract(gxy, es)
    ms = Extract('0', hs)

    hs_keys = Expand(Expand(hs, <'serverhts', <h(messages)>>, '32'), <'kshe_wk', '0'>, '32')
    hs_keyc = Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'kshe_wk', '0'>, '32')
in
    [ State(tid,'S2a',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      DHExp(y, tid, S)
    ]
  --[ S2a(tid),
      Extract('0', hs),
      Instance(tid, S, 'server'),
      RHS(tid, S, 'server', <hs>),
      RMS(tid, S, 'server', <ms>),
      DeleteDH(tid, S, y)
   ]->
    [ State(tid,'S2b',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule encrypted_extensions:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

    messages = <messages, <'8',$exts>>
in
    [ State(tid,'S2b',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req )
    ]
  --[ S2b(tid),
      Instance(tid, S, 'server')
    ]->
    [ State(tid,'S2c',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      Out(senc{<'8',$exts>}hs_keys)
    ]

rule certificate_request:
let
    p_psk_ke_mode = 'na'
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

    certificate_request_context = '0' 
    cert_req = '1' 
    messages = <messages,  <'13',  certificate_request_context,  $certificate_extensions >>
in
    [ State(tid,'S2c',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req )
    ]
  --[ S2c_req(tid),
      Instance(tid, S, 'server'),
      RCertReqCtxt(tid, S, 'server', <certificate_request_context>)
    ]->
    [ State(tid,'S2d',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      Out(senc{ <'13',  certificate_request_context,  $certificate_extensions >}hs_keys)
    ]

rule skip_certificate_request:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    cert_req = '0'

    S = $S
    C = $C
in
    [ State(tid,'S2c',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req )
    ]
  --[ S2c(tid),
      Instance(tid, S, 'server')
    ]->
    [ State(tid,'S2d',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule server_auth:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    certificate_request_context = '0'
    certificate = pk(~ltkS)
    messages = <messages, <'11',certificate_request_context,certificate>>
    signature = sign{<'server_cv', <h(messages)>>}~ltkS

    messages = <messages, <'15',  signature >>

    verify_data = hmac(Expand(Expand(hs, <'serverhts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>
    ems = Expand(ms, <'ems', <h(messages)>>, '32')
    cats = Expand(ms, <'clientats', <h(messages)>>, '32')
    sats = Expand(ms, <'serverats', <h(messages)>>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')

    // auth_status = <sas, cas>
    auth_status = <'auth', '0'>
in
    [ State(tid,'S2d',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      !Ltk(S, ~ltkS)
    ]
  --[ S2d(tid),
      Instance(tid, S, 'server'),
      Eq(psk_ke_mode, 'na'),
      UseLtk(~ltkS, signature),
      RTranscript(tid, S, 'server', <messages>)
    ]->
    [ State(tid,'S3',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      Out(senc{<'11',certificate_request_context,certificate>, <'15',  signature >, <'20',verify_data>}hs_keys)
    ]

rule recv_client_auth:
let
    p_cert_req = '0'
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    exp_verify_data = hmac(Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>

    rms = Expand(ms, <'rms', <h(messages)>>, '32')

    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State(tid,'S3',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      In(senc{<'20',verify_data>}hs_keyc)
    ]
  --[ S3(tid),
      Instance(tid, S, 'server'),
      Eq(verify_data, exp_verify_data),
      RMode(tid, S, 'server', <psk_ke_mode>),
      CIdentity(tid, S, 'server', <C,auth_status>),
      CHS(tid, S, 'server', <hs>),
      RHSMS(tid, S, 'server', <hs,ms>),
      RRMS(tid, S, 'server', <C,rms,messages>),
      CTranscript(tid, S, 'server', <messages>),
      CNonces(tid, S, 'server', <nc,ns>),
      SessionKey(tid, S, C, auth_status, <app_keys, app_keyc>)
    ]->
    [ State(tid,'S4',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, S, C, auth_status, app_keyc)
    ]

rule recv_client_auth_cert:
let
    p_cert_req = '1'
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    certificate = pk(~ltkC)
    certificate_request_context ='0' 
    messages = <messages, <'11',certificate_request_context,certificate>>

    sig_messages = <'client_cv', <h(messages)>>
    messages = <messages, <'15',  signature >>

    exp_verify_data = hmac(Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>
    rms = Expand(ms, <'rms', <h(messages)>>, '32')

    cert_req = '0'
    auth_status = <'auth', 'auth'>

    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State(tid,'S3',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      !Pk(C, pk(~ltkC)),
      SendStream(tid, S, C, p_auth_status, app_keys),
      In(senc{<'11',certificate_request_context,certificate>, <'15',  signature >, <'20',verify_data>}hs_keyc)
    ]
  --[ S3_cert(tid),
      Instance(tid, S, 'server'),
      Eq(verify(signature, sig_messages, pk(~ltkC)), true),
      Eq(verify_data, exp_verify_data),
      RMode(tid, S, 'server', <psk_ke_mode>),
      CIdentity(tid, S, 'server', <C,auth_status>),
      CHS(tid, S, 'server', <hs>),
      RHSMS(tid, S, 'server', <hs,ms>),
      RRMS(tid, S, 'server', <C,rms,messages>),
      CTranscript(tid, S, 'server', <messages>),
      SessionKey(tid, S, C, auth_status, <app_keys, app_keyc>),
      CNonces(tid, S, 'server', <nc,ns>)
    ]->
    [ State(tid,'S4',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      RecvStream(tid, S, C, auth_status, app_keyc)
    ]

// msgs.m4i imports

// crypto.m4i imports

// state.m4i imports

rule client_hello_psk:
let
    // Initialises all state variables to zero.
     messages = '0'
res_psk = '0'
nc = '0'
ns = '0'
g = '0'
sg = '0'
hrr = '0'
x = '0'
y = '0'
gx = '0'
gy = '0'
gxy = '0'
psk_ke_mode = 'na'
psk_id = '0'
edi = '0'
es = '0'
hs = '0'
ms = '0'
cats = '0'
sats = '0'
hs_keyc = '0'
hs_keys = '0'
auth_status = <'0', '0'>
ems = '0'
rms = '0'
cert_req = '0'

    edi = <'42','0'>

    // Set resumption values from ClientPSK
    res_psk = p_res_psk
    auth_status = p_auth_status
    psk_id = ticket
    psk_ke_mode = <'0', '1'>     obfuscated_ticket_age = mask(ticket_age_add, $ticket_age)
    identities = <<ticket, obfuscated_ticket_age>>

    // Abstract client identity - does not currently correspond to 
    // anything concrete 
    C = $C

    // Server identity - can be interpreted as the hostname
    S = $S

    // Client nonce
    nc = ~nc

    // We reuse the client nonce to be a thread identifier
    tid = nc

    g1 = $g1
    g2 = $g2
    sg= <g1, g2>
    client_sg = <g1, g2>

    // Group, DH exponent, key share
    g = g1
    x = ~x
    gx = g^x

    es = Extract(res_psk, '0')
    binder = '0'
    binder_messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<   <'43','0x0304'>,  <'10',client_sg>,  <'40',g,gx>,  <'45',psk_ke_mode>,  edi,  <'41',identities,<binder>> > >>
    binder = hmac(Expand(Expand(es, <<psk_type, 'pbk'>>, '32'), <binder, '0'>, '32'), h(binder_messages))
    messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<   <'43','0x0304'>,  <'10',client_sg>,  <'40',g,gx>,  <'45',psk_ke_mode>,  edi,  <'41',identities,<binder>> > >>

    ead_keyc = Expand(Expand(es, <'cets', <h(messages)>>, '32'), <'eadke_wk', '0'>, '32')
in
    [ Fr(nc),
      Fr(x),
      // XXX: For some reason using oob PSK explodes memory usage...
      !ClientPSK(C, S, p_res_psk, p_auth_status, <'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >, psk_type)
    ]
  --[ C0_PSK(tid),
      Start(tid, C, 'client'),
      RPSK(tid, C, 'client', <S,p_res_psk,p_auth_status>),
      Neq(p_res_psk, '0'),
      DH(tid, C, x)
    ]->
    [
      State(tid,'C1',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      F_CachePSK(tid,S,p_res_psk,p_auth_status,<'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >,psk_type),
      EarlySendStream(tid, C, S, auth_status, ead_keyc, edi),
      DHExp(x, tid, C),
    // Write the ClientHelloMsg onto the wire *presumably* with destination S
      Out(<'1','0x0303',nc,'0',$cipher_suites,'0',<   <'43','0x0304'>,  <'10',client_sg>,  <'40',g,gx>,  <'45',psk_ke_mode>,  edi,  <'41',identities,<binder>> > >)
    ]

rule recv_hello_retry_request_psk:
let
    g1 = $g1
    g2 = $g2
    p_sg = <g1, g2>
    p_g = g1
    p_hrr = '0'

    p_psk_ke_mode = <'0', '1'>
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    // Set resumption values from ClientPSK
    res_psk = p_res_psk
    auth_status = p_auth_status
    psk_id = ticket
    psk_ke_mode = <'0', '1'>     obfuscated_ticket_age = mask(ticket_age_add, '1')
    identities = <<ticket, obfuscated_ticket_age>>
    edi = '0'

    hrr = 'hrr'
    new_g = g2
    g = g2
    client_sg = <g1, g2>

    C = $C
    S = $S

    new_nc = ~new_nc
    new_x = ~new_x
    x = new_x
    gx = g^x
    nc = new_nc

    es = Extract(res_psk, '0')
    messages = <messages, <'6',    '0x0303',    <<'40',new_g>> >>
    tmp_messages = messages
    binder = '0'
    binder_messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<   <'43','0x0304'>,  <'10',client_sg>,  <'40',g,gx>,  <'45',psk_ke_mode>,  edi,  <'41',identities,<binder>> > >>
    binder = hmac(Expand(Expand(es, <<psk_type, 'pbk'>>, '32'), <binder, '0'>, '32'), h(binder_messages))
    messages = <tmp_messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<   <'43','0x0304'>,  <'10',client_sg>,  <'40',g,gx>,  <'45',psk_ke_mode>,  edi,  <'41',identities,<binder>> > >>
in
    [ State(tid,'C1',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      F_CachePSK(tid,S,p_res_psk,p_auth_status,<'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >,psk_type),
      Fr(new_nc),
      Fr(new_x),
      DHExp(p_x, tid, C),
      In(<'6',    '0x0303',    <<'40',new_g>> >)
    ]
  --[ C1_retry_PSK(tid),
      Neq(g1, g2),
      Instance(tid, C, 'client'),
      RPSK(tid, C, 'client', <S,p_res_psk,p_auth_status>),
      DeleteDH(tid, C, p_x),
      DH(tid, C, x)
    ]->
    [ Out(<'1','0x0303',nc,'0',$cipher_suites,'0',<   <'43','0x0304'>,  <'10',client_sg>,  <'40',g,gx>,  <'45',psk_ke_mode>,  edi,  <'41',identities,<binder>> > >),
      DHExp(x, tid, C),
      State(tid,'C1',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_server_hello_psk_dhe:
let
    p_g = $g
    p_x = ~x
    p_psk_ke_mode = <'0', '1'>
    p_psk_id = ~ticket

    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    ns = new_ns
    gy = new_gy

    psk_ke_mode = '1'

    C = $C
    S = $S

    gy = g^new_y

    // Derive the shared secret
    gxy = gy^x

    identity = psk_id

    messages = <messages, <'2',  '0x0303',  ns,  $cipher_suite,  <   <'13',$sig_algs>,  <'40',g,gy>,  <'41','0'>,  edi > >>
in
    [ State(tid,'C1',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      In(<'2',  '0x0303',  ns,  $cipher_suite,  <   <'13',$sig_algs>,  <'40',g,gy>,  <'41','0'>,  edi > >)
    ]
  --[ C1_PSK_DHE(tid),
      Neq(gy, g),
      Instance(tid, C, 'client'),
      DHChal(g, x, new_y, gx, gy, gxy),
      RNonces(tid, C, 'client', <nc,ns>)
    ]->
    [
      State(tid,'C2a',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_server_hello_psk:
let
    p_psk_ke_mode = <'0', '1'>

    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    ns = new_ns

    psk_ke_mode = '0'

    C = $C
    S = $S

    identity = psk_id

    messages = <p_messages, <'2',  '0x0303',  ns,  $cipher_suite,  <   <'13',$sig_algs>,  <'41','0'>,  edi > >>
in
    [ State(tid,'C1',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      In(<'2',  '0x0303',  ns,  $cipher_suite,  <   <'13',$sig_algs>,  <'41','0'>,  edi > >)
    ]
  --[ C1_PSK(tid),
      Instance(tid, C, 'client'),
      RNonces(tid, C, 'client', <nc,ns>)
    ]->
    [
      State(tid,'C2a',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_server_auth_psk:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

    exp_verify_data = hmac(Expand(Expand(hs, <'serverhts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>

    cats = Expand(ms, <'clientats', <h(messages)>>, '32')
    sats = Expand(ms, <'serverats', <h(messages)>>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
    ems = Expand(ms, <'ems', <h(messages)>>, '32')
in
    [ State(tid,'C2d',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      In(senc{<'20',verify_data>}hs_keys)
    ]
  --[ C2d_PSK(tid),
      Neq(p_psk_ke_mode, 'na'),
      Instance(tid, C, 'client'),
      Eq(verify_data, exp_verify_data),
      RMode(tid, C, 'client', <psk_ke_mode>),
      CIdentity(tid, C, 'client', <<S,auth_status>>),
      CHS(tid, C, 'client', <hs>),
      CNonces(tid, C, 'client', <nc,ns>),
      CTranscript(tid, C, 'client', <messages>)
    ]->
    [ State(tid,'C3',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys)
    ]

rule recv_client_hello_psk:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    nc = new_nc
    g1 = $g1
    g2 = $g2
    client_sg = <g1, g2>
    nc = new_nc
    gx = new_gx
    g = $new_g
    gx = g^new_x

    ticket_age_add = ~ticket_age_add
    ticket = ~ticket
    res_psk = psk_res_psk
    auth_status = psk_auth_status
    identities = <<ticket, obfuscated_ticket_age>>
    ticket_age = unmask(obfuscated_ticket_age, ticket_age_add)
    psk_id = ticket
    psk_ke_mode = <'0', '1'>     edi = new_edi

    // Abstract client identity - does not currently correspond to 
    // anything concrete 
    // From the server's perspective: associate with an open socket.
    C = $C

    // Server identity - can be interpreted as the hostname
    S = $S

    // Server nonce
    ns = ~ns

    es = Extract(res_psk, '0')

    tmp_binder = binder
    binder = '0'
    binder_messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<   <'43','0x0304'>,  <'10',client_sg>,  <'40',g,gx>,  <'45',psk_ke_mode>,  edi,  <'41',identities,<binder>> > >>
    binder_check = hmac(Expand(Expand(es, <<psk_type, 'pbk'>>, '32'), <binder, '0'>, '32'), h(binder_messages))
    binder = tmp_binder
    messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<   <'43','0x0304'>,  <'10',client_sg>,  <'40',g,gx>,  <'45',psk_ke_mode>,  edi,  <'41',identities,<binder>> > >>

    ead_keyc = Expand(Expand(es, <'cets', <h(messages)>>, '32'), <'eadke_wk', '0'>, '32')
in
    [ State(tid,'S0',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      In(<'1','0x0303',nc,'0',$cipher_suites,'0',<   <'43','0x0304'>,  <'10',client_sg>,  <'40',g,gx>,  <'45',psk_ke_mode>,  edi,  <'41',identities,<binder>> > >),
      Fr(ns),
      !ServerPSK(S, C, psk_res_psk, psk_auth_status, <'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >, psk_type)
    ]
  --[ S0_PSK(tid),
      Neq(g1, g2),
      Eq(unmask(obfuscated_ticket_age, ticket_age_add), '1'),
      Eq(binder_check, binder),
      RPSK(tid, S, 'server', <C,psk_res_psk,psk_auth_status>),
      Neq(psk_res_psk, '0')
    ]->
    [
      State(tid,'S1',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      EarlyRecvStream(tid, S, C, auth_status, ead_keyc, edi)
    ]
/*
    Server sends ServerHello for PSK DHE mode
*/

rule server_hello_psk_dhe:
let
    p_g = $g
    p_gx = p_g^some_x
    p_psk_ke_mode = <'0', '1'>     p_ns = ~ns
    p_psk_id = ~ticket

    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    psk_ke_mode = '1'

    C = $C
    S = $S

    // Group, DH exponent, key share
    y = ~y
    gy = g^y
    gxy = gx^y

    identity = psk_id

    es = Extract(res_psk, '0')

    messages = <messages, <'2',  '0x0303',  ns,  $cipher_suite,  <   <'13',$sig_algs>,  <'40',g,gy>,  <'41','0'>,  edi > >>
in
    [ State(tid,'S1',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      Fr(y)
    ]
  --[ S1_PSK_DHE(tid),
      Neq(gx, g),
      Neq(x, inv(y)),
      Instance(tid, S, 'server'),
      DHChal(g, some_x, y, gx, gy, gxy),
      RNonces(tid, S, 'server', <nc,ns>),
      DH(tid, S, y)
    ]->
    [
      State(tid,'S2a',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      DHExp(y, tid, S),
      Out(<'2',  '0x0303',  ns,  $cipher_suite,  <   <'13',$sig_algs>,  <'40',g,gy>,  <'41','0'>,  edi > >)
    ]

rule server_hello_psk:
let
    p_psk_ke_mode = <'0', '1'>
    p_ns = ~ns
    p_psk_id = ~ticket

    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    psk_ke_mode = '0'

    C = $C
    S = $S

    es = Extract(res_psk, '0')
    messages = <messages, <'2',  '0x0303',  ns,  $cipher_suite,  <   <'13',$sig_algs>,  <'41','0'>,  edi > >>

    // y is not actually used anywhere - this isn't DHE mode
    y = ~y_ignored
in
    [ State(tid,'S1',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      Fr(y)
    ]
  --[ S1_PSK(tid),
      Instance(tid, S, 'server'),
      RNonces(tid, S, 'server', <nc,ns>),
      DH(tid, S, y)
    ]->
    [
      State(tid,'S2a',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      DHExp(y, tid, S),
      Out(<'2',  '0x0303',  ns,  $cipher_suite,  <   <'13',$sig_algs>,  <'41','0'>,  edi > >)
    ]

rule server_auth_psk:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    verify_data = hmac(Expand(Expand(hs, <'serverhts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>

    cats = Expand(ms, <'clientats', <h(messages)>>, '32')
    sats = Expand(ms, <'serverats', <h(messages)>>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
    ems = Expand(ms, <'ems', <h(messages)>>, '32')

in
    [ State(tid,'S2d',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req )
    ]
  --[ S2d_PSK(tid),
      Neq(p_psk_ke_mode, 'na'),
      Instance(tid, S, 'server'),
      RTranscript(tid, S, 'server', <messages>)
    ]->
    [ State(tid,'S3',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      Out(senc{<'20',verify_data>}hs_keys)
    ]

rule send:
    [ SendStream(~tid, $actor, $peer, auth_status, app_key_out),
      Fr(~data)
    ]
  --[ Send(~tid),
      SendData(~tid, $actor, $peer, auth_status, ~data)
    ]->
    [ SendStream(~tid, $actor, $peer, auth_status, app_key_out),
      Out(senc{<~data, '23'>}app_key_out)
    ]

rule recv:
    [ RecvStream(~tid, $actor, $peer, auth_status, app_key_in),
      In(senc{<data, '23'>}app_key_in)
    ]
  --[ Recv(~tid),
      RecvData(~tid, $actor, $peer, auth_status, data)
    ]->
    [
      RecvStream(~tid, $actor, $peer, auth_status, app_key_in)
    ]

// msgs.m4i imports

// crypto.m4i imports

// state.m4i imports

rule end_early_data:
let
    C = $C
    S = $S
in
    [ EarlySendStream(tid, C, S, auth_status, ead_keyc, <'42','0'>)
    ]
  --[
      C_EndZeroRTT(tid)
    ]->
    [
      Out(senc{<'1', '21'>}ead_keyc)
    ]
rule recv_end_early_data:
let
    C = $C
    S = $S
in
    [ EarlyRecvStream(tid, S, C, auth_status, ead_keyc, <'42','0'>),
      In(senc{<'1', '21'>}ead_keyc)
    ]
  --[
      S_RecvEndZeroRTT(tid)
    ]->
    [
    ]

rule send_early_data:
let
    C = $C
    S = $S
in
    [ EarlySendStream(tid, C, S, auth_status, ead_keyc, <'42','0'>),
      Fr(~data)
    ]
  --[ C_SendZeroRTT(tid)
    ]->
    [ EarlySendStream(tid, C, S, auth_status, ead_keyc, <'42','0'>),
      Out(senc{<~data, '23'>}ead_keyc)
    ]

rule recv_early_data:
let
    C = $C
    S = $S
in
    [ EarlyRecvStream(tid, S, C, auth_status, ead_keyc, <'42','0'>),
      In(senc{<data, '23'>}ead_keyc)
    ]
  --[ S_RecvZeroRTT(tid)
    ]->
    [
      EarlyRecvStream(tid, S, C, auth_status, ead_keyc, <'42','0'>)
    ]

rule out_of_band_psk:
let
    C = $C
    S = $S
    res_psk = ~res_psk
    ticket = ~ticket
    ticket_age_add = ~ticket_age_add

    // Implicitly authed perhaps...
    auth_status = <'oob_auth', 'oob_auth'>
in
    [ Fr(ticket), Fr(res_psk), Fr(~ticket_age_add)]
  --[ GenPSK(S, 'server'), GenPSK(C, 'client'),
      FreshPSK(ticket,res_psk)
    ]->
    [ !ClientPSK(C, S, res_psk, auth_status, <'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >, 'ext'),
      !ServerPSK(S, C, res_psk, auth_status, <'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >, 'ext'),
      F_SecretPSK(S,res_psk),
      F_SecretPSK(C,res_psk)
    ]

rule new_session_ticket:
let
    p_rms = Expand(ms, <'rms', <h(messages)>>, '32')
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    ticket = ~ticket
    ticket_age_add = ~ticket_age_add

    res_psk = rms
in
    [ State(tid,'S4',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      Fr(ticket),
      Fr(ticket_age_add)
    ]
  --[ S4_NST(tid),
      Instance(tid, S, 'server'),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>),
      RNST(tid, S, 'server', <ticket,ticket_age_add>)
    ]->
    [ State(tid,'S4',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      !ServerPSK(S, C, res_psk, auth_status, <'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >, 'res'),
      F_SecretPSK(S,res_psk),
      Out(senc{<'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >}app_keys)
    ]

rule recv_new_session_ticket:
let
    p_rms = Expand(ms, <'rms', <h(messages)>>, '32')
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    res_psk = rms
in
    [ State(tid,'C4',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys),
      In(senc{<'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >}app_keys)
    ]
  --[ C4_NST(tid),
      Instance(tid, C, 'client'),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State(tid,'C4',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys),
      !ClientPSK(C, S, res_psk, auth_status, <'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >, 'res'),
      F_SecretPSK(C,res_psk)
    ]

rule certificate_request_post:
let
//    p_cert_req_ctxt = '0'
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

    certificate_request_context = ~cert_req_ctxt
//    cert_req_ctxt = ~cert_req_ctxt
in
    [ State(tid,'S4',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      SendStream(tid, S, C, p_auth_status, app_keys),
      Fr(certificate_request_context)
    ]
  --[ S4_req(tid),
      Instance(tid, S, 'server'),
      RCertReqCtxt(tid, S, 'server', <certificate_request_context>),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>)
    ]->
    [ State(tid,'S4',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      L_ServerCertReq(tid,S,C,certificate_request_context),
      Out(senc{ <'13',  certificate_request_context,  $certificate_extensions >}app_keys)
    ]

rule recv_certificate_request_post:
let
//    p_cert_req_ctxt = '0'
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

//    cert_req_ctxt = certificate_request_context
in
    [ State(tid,'C4',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      RecvStream(tid, C, S, p_auth_status, app_keys),
      In(senc{ <'13',  certificate_request_context,  $certificate_extensions >}app_keys)
    ]
  --[ C4_req(tid),
      Neq(certificate_request_context, '0'),
      Instance(tid, C, 'client'),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State(tid,'C4',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys),
      L_ClientCertReq(tid,C,S,certificate_request_context)
    ]

rule client_auth_post:
let
  p_auth_status = <p_cas, p_sas>
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    S = $S
    C = $C

//    certificate_request_context = p_cert_req_ctxt
    certificate = pk(~ltkC)

    tmp_messages = messages
    messages = <messages,  <'13',  certificate_request_context,  $certificate_extensions >>

    signature = sign{<'client_cv', <h(messages)>>}~ltkC

    fin_keyc = Expand(cats, <'fin', '0'>, '32')
    verify_data = hmac(Expand(Expand(hs, <'fin_keychts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

//    cert_req_ctxt = '0'
    messages = tmp_messages

    auth_status = <'auth', p_sas>
in

    [ State(tid,'C4',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      SendStream(tid, C, S, p_auth_status, app_keyc),
      !Ltk(C, ~ltkC),
      L_ClientCertReq(tid,C,S,certificate_request_context)
    ]
  --[ C4_cert(tid),
      Instance(tid, C, 'client'),
      Neq(certificate_request_context, '0'),
      UseLtk(~ltkC, signature),
      RTranscriptPost(tid, C, 'client', <messages,certificate_request_context>),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State(tid,'C4',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, C, S, auth_status, app_keyc),
      Out(senc{<'11',certificate_request_context,certificate>, <'15',  signature >, <'20',verify_data>}app_keyc)
    ]

rule recv_client_auth_post:
let
    p_auth_status = <p_sas, p_cas>
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    certificate = pk(~ltkC)
    certificate_request_context = ~cert_req_ctxt

    tmp_messages = messages
    messages = <messages,  <'13',  certificate_request_context,  $certificate_extensions >>

    sig_messages = <'client_cv', <h(messages)>>

    fin_keyc = Expand(cats, <'fin', '0'>, '32')
    exp_verify_data = hmac(Expand(Expand(hs, <'fin_keychts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

//    cert_req_ctxt = '0'
    auth_status = <p_sas, 'auth'>
    messages = tmp_messages
in
    [ State(tid,'S4',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      RecvStream(tid, S, C, p_auth_status, app_keyc),
      !Pk(C, pk(~ltkC)),
      L_ServerCertReq(tid,S,C,certificate_request_context),
      In(senc{<'11',certificate_request_context,certificate>, <'15',  signature >, <'20',verify_data>}app_keyc)
    ]
  --[ S4_cert(tid),
      Instance(tid, S, 'server'),
      Neq(certificate_request_context, '0'),
      Eq(verify(signature, sig_messages, pk(~ltkC)), true),
      Eq(verify_data, exp_verify_data),
      CIdentityPost(tid, S, 'server', <<C,auth_status>>),
      CTranscriptPost(tid, S, 'server', <messages,certificate_request_context>),
      CHS(tid, S, 'server', <hs>),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>)
    ]->
    [ State(tid,'S4',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, S, C, auth_status, app_keyc)
    ]

rule update_req_client:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    cats = Expand(p_cats, <'ats', '0'>, '32')
    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
in
    [ State(tid,'C4',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      SendStream(tid, C, S, p_auth_status, p_app_keyc)
    ]
  --[ C4_update_req(tid),
      Instance(tid, C, 'client'),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State(tid,'C4',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, C, S, auth_status, app_keyc),
      Out(senc{<'24','1'>}p_app_keyc)
    ]

rule update_req_server:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    sats = Expand(p_sats, <'ats', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State(tid,'S4',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      SendStream(tid, S, C, p_auth_status, p_app_keys)
    ]
  --[ S4_update_req(tid),
      Instance(tid, S, 'server'),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>)
    ]->
    [ State(tid,'S4',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      Out(senc{<'24','1'>}p_app_keys)
    ]

rule update_recv_client:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    cats = Expand(p_cats, <'ats', '0'>, '32')
    sats = Expand(p_sats, <'ats', '0'>, '32')
    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State(tid,'C4',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      RecvStream(tid, C, S, p_auth_status, p_app_keys),
      SendStream(tid, C, S, p_auth_status, p_app_keyc),
      In(senc{<'24','1'>}p_app_keys)
    ]
  --[ C4_update_recv(tid),
      Instance(tid, C, 'client'),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State(tid,'C4',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys),
      SendStream(tid, C, S, auth_status, app_keyc),
      Out(senc{<'24','0'>}p_app_keyc)
    ]

rule update_recv_server:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    cats = Expand(p_cats, <'ats', '0'>, '32')
    sats = Expand(p_sats, <'ats', '0'>, '32')
    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State(tid,'S4',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      RecvStream(tid, S, C, p_auth_status, p_app_keyc),
      SendStream(tid, S, C, p_auth_status, p_app_keys),
      In(senc{<'24','1'>}p_app_keyc)
    ]
  --[ S4_update_recv(tid),
      Instance(tid, S, 'server'),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>)
    ]->
    [ State(tid,'S4',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, S, C, auth_status, app_keyc),
      SendStream(tid, S, C, auth_status, app_keys),
      Out(senc{<'24','0'>}p_app_keys)
    ]

rule update_fin_client:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    sats = Expand(p_sats, <'ats', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State(tid,'C4',C,S, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      RecvStream(tid, C, S, p_auth_status, p_app_keys),
      In(senc{<'24','0'>}p_app_keys)
    ]
  --[ C4_update_fin(tid),
      Instance(tid, C, 'client'),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State(tid,'C4',C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys)
    ]

rule update_fin_server:
let
    
res_psk = p_res_psk
nc = p_nc
ns = p_ns
g = p_g
sg = p_sg
x = p_x
y = p_y
gx = p_gx
gy = p_gy
gxy = p_gxy
hrr = p_hrr
psk_ke_mode = p_psk_ke_mode
psk_id = p_psk_id
edi = p_edi
es = p_es
hs = p_hs
ms = p_ms
cats = p_cats
sats = p_sats
hs_keyc = p_hs_keyc
hs_keys = p_hs_keys
auth_status = p_auth_status
messages = p_messages
ems = p_ems
rms = p_rms
cert_req = p_cert_req
tid = ~tid

    C = $C
    S = $S

    cats = Expand(p_cats, <'ats', '0'>, '32')
    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
in
    [ State(tid,'S4',S,C, p_res_psk,p_messages,p_nc,p_ns,p_g,p_sg,p_hrr,p_x,p_y,p_gx,p_gy,p_gxy,p_psk_ke_mode,p_psk_id,p_edi,p_es,p_hs,p_ms,p_cats,p_sats,p_hs_keyc,p_hs_keys,p_auth_status,p_ems,p_rms,p_cert_req ),
      RecvStream(tid, S, C, p_auth_status, p_app_keyc),
      In(senc{<'24','0'>}p_app_keyc)
    ]
  --[ S4_update_fin(tid),
      Instance(tid, S, 'server'),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>)
    ]->
    [ State(tid,'S4',S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, S, C, auth_status, app_keyc)
    ]

rule Reveal_Ltk:
  [ !Ltk($A, ~ltkA) ] --[ RevLtk($A) ]-> [ Out(~ltkA) ]

rule Reveal_DHExp:
  [ DHExp(~x, ~tid, $A) ] --[ RevDHExp(~tid, $A,~x) ]-> [ Out(~x), DHExp(~x, ~tid, $A) ]

rule Reveal_PSK:
    [ F_SecretPSK($A,res_psk)]--[ RevealPSK($A, res_psk) ]->[Out(res_psk)]

/*
  TYPING LEMMAS
*/

/*
  LEMMAS USED IN AUTH_HELPERS
  
*/

/*
  LEMMAS USED IN SECRET_HELPERS

*/

/*
  LEMMAS USED IN LEMMA

*/

/*
  LEMMAS USED IN DH_INJ

*/

//NTS: RevDH < RRMS
//May have to add tid's to RevDH. 

lemma one_C2d_per_tid [reuse]:
    "All tid #i #j. C2d(tid)@i & C2d(tid)@j ==> #i = #j"

lemma one_C2d_PSK_per_tid [reuse]:
    "All tid #i #j. C2d_PSK(tid)@i & C2d_PSK(tid)@j ==> #i = #j"

lemma one_S2d_per_tid [reuse]:
    "All tid #i #j. S2d(tid)@i & S2d(tid)@j ==> #i = #j"

lemma one_S2d_PSK_per_tid [reuse]:
    "All tid #i #j. S2d_PSK(tid)@i & S2d_PSK(tid)@j ==> #i = #j"

lemma one_C3_per_tid [reuse]:
    "All tid #i #j. C3(tid)@i & C3(tid)@j ==> #i = #j"

lemma one_C3_cert_per_tid [reuse]:
    "All tid #i #j. C3_cert(tid)@i & C3_cert(tid)@j ==> #i = #j"

lemma one_S3_per_tid [reuse]:
    "All tid #i #j. S3(tid)@i & S3(tid)@j ==> #i = #j"

lemma one_S3_cert_per_tid [reuse]:
    "All tid #i #j. S3_cert(tid)@i & S3_cert(tid)@j ==> #i = #j"

lemma S3_vs_S3_cert [reuse]:
    "All tid #i #j. S3(tid)@i & S3_cert(tid)@j ==> F"

lemma C3_vs_C3_cert [reuse]:
    "All tid #i #j. C3(tid)@i & C3_cert(tid)@j ==> F"

lemma S2d_vs_S2d_PSK [reuse]:
    "All tid #i #j. S2d(tid)@i & S2d_PSK(tid)@j ==> F"

lemma C2d_vs_C2d_PSK [reuse]:
    "All tid #i #j. C2d(tid)@i & C2d_PSK(tid)@j ==> F"

lemma tid_invariant [use_induction, reuse]:
  "All tid actor role #i. Instance(tid, actor, role)@i==>
      (Ex #j. Start(tid, actor, role)@j & (#j < #i))"
/* [use_induction, reuse]:
  "All tid actor role #i. Instance(tid, actor, role)@i==>
      (Ex #j. Start(tid, actor, role)@j & (#j < #i))"
*/

lemma one_start_per_tid [reuse]:
  "All tid actor actor2 role role2 #i #j. Start(tid, actor, role)@i & Start(tid, actor2, role2)@j ==>#i=#j"
/* [reuse]:
  "All tid actor actor2 role role2 #i #j. Start(tid, actor, role)@i & Start(tid, actor2, role2)@j ==>#i=#j"
*/

lemma cert_req_origin [typing]:
  "All certificate_request_context certificate_extensions keys #i.
    KU(senc{<'13',certificate_request_context,certificate_extensions>}keys)@i ==> 
      (Ex #j. KU(certificate_request_context)@j & #j < #i) |
      (Ex #j tid actor role. RCertReqCtxt(tid, actor, role, <certificate_request_context>)@j & #j < #i)"
/* [typing]:
  "All certificate_request_context certificate_extensions keys #i.
    KU(senc{handshake_record('13', certificate_request_context, certificate_extensions)}keys)@i ==> 
      (Ex #j. KU(certificate_request_context)@j & #j < #i) |
      (Ex #j tid actor role. running(CertReqCtxt, actor, role, certificate_request_context)@j & #j < #i)"
*/

lemma nst_source [typing]:
  "All ticket ticket_age_add tkt_lt tkt_exts app_key #i.
    KU(senc{<'4',tkt_lt,ticket_age_add,ticket,tkt_exts>}app_key)@i ==>
      (Ex #j #k. KU(ticket)@j & KU(ticket_age_add)@k & #j < #i & #k < #i) |
      (Ex tid S #j. RNST(tid, S, 'server', <ticket,ticket_age_add>)@j & #j < #i)"
/* [typing]:
  "All ticket ticket_age_add tkt_lt tkt_exts app_key #i.
    KU(senc{handshake_record('4', tkt_lt, ticket_age_add, ticket, tkt_exts)}app_key)@i ==>
      (Ex #j #k. KU(ticket)@j & KU(ticket_age_add)@k & #j < #i & #k < #i) |
      (Ex tid S #j. running_server(NST, ticket, ticket_age_add)@j & #j < #i)"
*/

end
