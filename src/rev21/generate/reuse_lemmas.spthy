theory TLS_13_Reuse_Lemmas
begin

builtins: diffie-hellman, hashing, symmetric-encryption, signing

functions: Expand/3, Extract/2, hmac/1, mac/1, mask/2, unmask/2

equations: unmask(mask(x, y), y) = x, unmask(mask(x, y), x) = y

restriction Eq_check_succeed: "All x y #i. Eq(x,y) @ i ==> x = y"
restriction Neq_check_succeed: "All x y #i. Neq(x,y) @ i ==> not (x = y)"

/* Generate one long-term key per actor */
restriction one_ltk:
  "All A x y #i #j.
    GenLtk(A, x)@i & GenLtk(A, y)@j ==> #i = #j"

restriction one_role_per_actor:
    "All actor tid tid2 role role2 #i #j. Start(tid, actor, role)@i & Start(tid2, actor, role2)@j
        ==> role = role2"

// May be derived from the unify data flow graph, but likely not sufficient. Relies on freshness of tid and when the action facts occur
// Says they can both co-occur, but only in the same rule instance

lemma one_C0_per_tid [reuse]:
    "All tid #i #j. C0(tid)@i & C0(tid)@j ==> #i = #j"

lemma one_C1_per_tid [reuse]:
    "All tid #i #j. C1(tid)@i & C1(tid)@j ==> #i = #j"

lemma one_C1_retry_per_tid [reuse]:
    "All tid #i #j. C1_retry(tid)@i & C1_retry(tid)@j ==> #i = #j"

lemma one_S1_per_tid [reuse]:
    "All tid #i #j. S1(tid)@i & S1(tid)@j ==> #i = #j"

lemma one_S1_PSK_per_tid [reuse]:
    "All tid #i #j. S1_PSK(tid)@i & S1_PSK(tid)@j ==> #i = #j"

lemma one_S1_PSK_DHE_per_tid [reuse]:
    "All tid #i #j. S1_PSK_DHE(tid)@i & S1_PSK_DHE(tid)@j ==> #i = #j"

lemma one_C1_PSK_per_tid [reuse]:
    "All tid #i #j. C1_PSK(tid)@i & C1_PSK(tid)@j ==> #i = #j"

lemma one_C1_PSK_DHE_per_tid [reuse]:
    "All tid #i #j. C1_PSK_DHE(tid)@i & C1_PSK_DHE(tid)@j ==> #i = #j"

lemma one_S2a_per_tid [reuse]:
    "All tid #i #j. S2a(tid)@i & S2a(tid)@j ==> #i = #j"

lemma one_S2b_per_tid [reuse]:
    "All tid #i #j. S2b(tid)@i & S2b(tid)@j ==> #i = #j"

lemma one_S2c_per_tid [reuse]:
    "All tid #i #j. S2c(tid)@i & S2c(tid)@j ==> #i = #j"

lemma one_S2c_req_per_tid [reuse]:
    "All tid #i #j. S2c_req(tid)@i & S2c_req(tid)@j ==> #i = #j"

lemma one_S2d_per_tid [reuse]:
    "All tid #i #j. S2d(tid)@i & S2d(tid)@j ==> #i = #j"

lemma one_S2d_PSK_per_tid [reuse]:
    "All tid #i #j. S2d_PSK(tid)@i & S2d_PSK(tid)@j ==> #i = #j"

lemma one_C2a_per_tid [reuse]:
    "All tid #i #j. C2a(tid)@i & C2a(tid)@j ==> #i = #j"

lemma one_C2b_per_tid [reuse]:
    "All tid #i #j. C2b(tid)@i & C2b(tid)@j ==> #i = #j"

lemma one_C2c_per_tid [reuse]:
    "All tid #i #j. C2c(tid)@i & C2c(tid)@j ==> #i = #j"

lemma one_C2c_req_per_tid [reuse]:
    "All tid #i #j. C2c_req(tid)@i & C2c_req(tid)@j ==> #i = #j"

lemma one_C2d_per_tid [reuse]:
    "All tid #i #j. C2d(tid)@i & C2d(tid)@j ==> #i = #j"

lemma one_C2d_PSK_per_tid [reuse]:
    "All tid #i #j. C2d_PSK(tid)@i & C2d_PSK(tid)@j ==> #i = #j"

lemma one_C3_per_tid [reuse]:
    "All tid #i #j. C3(tid)@i & C3(tid)@j ==> #i = #j"

lemma one_C3_cert_per_tid [reuse]:
    "All tid #i #j. C3_cert(tid)@i & C3_cert(tid)@j ==> #i = #j"

lemma one_S3_per_tid [reuse]:
    "All tid #i #j. S3(tid)@i & S3(tid)@j ==> #i = #j"

lemma one_S3_cert_per_tid [reuse]:
    "All tid #i #j. S3_cert(tid)@i & S3_cert(tid)@j ==> #i = #j"

// Says they can never co-occur for a given tid

lemma S1_vs_S1_PSK_DHE [reuse]:
    "All tid #i #j. S1(tid)@i & S1_PSK_DHE(tid)@j ==> F"

lemma S1_PSK_vs_S1_PSK_DHE [reuse]:
    "All tid #i #j. S1_PSK(tid)@i & S1_PSK_DHE(tid)@j ==> F"

lemma S1_PSK_vs_S1 [reuse]:
    "All tid #i #j. S1_PSK(tid)@i & S1(tid)@j ==> F"

lemma C1_vs_C1_PSK_DHE [reuse]:
    "All tid #i #j. C1(tid)@i & C1_PSK_DHE(tid)@j ==> F"

lemma C1_PSK_vs_C1_PSK_DHE [reuse]:
    "All tid #i #j. C1_PSK(tid)@i & C1_PSK_DHE(tid)@j ==> F"

lemma C1_PSK_vs_C1 [reuse]:
    "All tid #i #j. C1_PSK(tid)@i & C1(tid)@j ==> F"

lemma S3_vs_S3_cert [reuse]:
    "All tid #i #j. S3(tid)@i & S3_cert(tid)@j ==> F"

lemma C3_vs_C3_cert [reuse]:
    "All tid #i #j. C3(tid)@i & C3_cert(tid)@j ==> F"

lemma S2d_vs_S2d_PSK [reuse]:
    "All tid #i #j. S2d(tid)@i & S2d_PSK(tid)@j ==> F"

lemma C2d_vs_C2d_PSK [reuse]:
    "All tid #i #j. C2d(tid)@i & C2d_PSK(tid)@j ==> F"

// Standard invariants: exists a Start action with same term args for all Instance actions
// Would not be detected in the default model since it uses different state facts for different stages of the protocol
lemma tid_invariant [use_induction, reuse]:
  "All tid actor role #i. Instance(tid, actor, role)@i==>
      (Ex #j. Start(tid, actor, role)@j & (#j < #i))"

// Require all action fact and fresh value pairings are unique (needs all instatiations of that action fact to use a fresh term in that position)
// Thus invariant (action) fact + fresh term = other invariant terms are always fixed at a given start (and hence every subsequent occurrence)

// (Start, tid) => (actor, role, timepoint)
lemma one_start_per_tid [reuse]:
  "All tid actor actor2 role role2 #i #j. Start(tid, actor, role)@i & Start(tid, actor2, role2)@j ==>#i=#j"

// (RNonce, tid) => (actor, role, nonces, timepoint)
lemma invariant_nonces [reuse]:
  "All tid actor actor2 role role2 nonces nonces2 #i #j.
    RNonces(tid, actor, role, <nonces>)@i & 
    RNonces(tid, actor2, role2, <nonces2>)@j ==> #i = #j"

// (DH, x) => (tid, actor, timepoint)
lemma one_dh_per_x  [reuse]:
  "All tid tid2 x actor actor2 #i #j. 
    DH(tid, actor, x)@i & DH(tid2, actor2, x)@j ==> #i = #j"

// Require all occurrences of a pair of action facts with matching term arguments X also have matching term arguments Y
// Can we derive these correlation automatically?

// (role, nonces) => (tid, actor)
lemma matching_nonces [reuse]:
  "All tid tid2 actor actor2 role  nonces #i #j. 
    RNonces(tid, actor, role, <nonces>)@i & 
    RNonces(tid2, actor2, role, <nonces>)@j ==>
    tid = tid2 & actor = actor2"

// (role, rms) => (actor, tid)
lemma matching_rms_actors [reuse]:
  "All tid tid2 actor peer actor2 peer2 role rms messages messages2 #i #j.
    RRMS(tid, actor, role, <peer,rms,messages>)@i &
    RRMS(tid2, actor2, role, <peer2,rms,messages2>)@j ==>
     actor = actor2 & tid = tid2"

// (tid, actor, role) => (peer, rms, msgs, hs)
lemma invariant_post_hs [reuse, use_induction, hide_lemma=posths_rms]:
  "All tid actor peer peer2 role hs hs2 rms rms2 as as2 msgs msgs2 #i #j.
    RPostHS(tid, actor, role, <hs,rms,peer,as,msgs>)@i & 
    RPostHS(tid, actor, role, <hs2,rms2,peer2,as2,msgs2>)@j ==>
      peer = peer2 & rms = rms2 & msgs = msgs2 & hs = hs2"

// An exception to the above, since it has two different action facts to compare - why?

// (tid, actor, role) => (hs)
lemma matching_hsms [reuse]:
  "All tid actor role hs hs2 ms #i #j.
    CHS(tid, actor, role, <hs2>)@i &
    RHSMS(tid, actor, role, <hs,ms>)@j ==>
      hs = hs2"

// The following lemmas are role-wise, i.e. the different actions facts occur on the client and server
// Roles can be easily extracted if represented as a term argument - perhaps not so obvious for fact symbols (can be derived via the unify data flow graph?)

// Role-wise (message) => (rms)
lemma matching_transcripts_posths [reuse]:
  "All tid tid2 actor peer actor2 peer2 role role2 rms rms2 messages #i #j.
    RRMS(tid, actor, role, <peer2,rms,messages>)@i &
    RRMS(tid2, peer, role2, <actor2,rms2,messages>)@j & not (role = role2) ==>
     rms = rms2"

// Role-wise (rms) => (message)
lemma matching_rms_posths [reuse]:
  "All tid tid2 actor peer actor2 peer2 role role2 rms messages messages2 #i #j.
    RRMS(tid, actor, role, <peer2,rms,messages>)@i &
    RRMS(tid2, peer, role2, <actor2,rms,messages2>)@j & not (role = role2) ==>
     messages = messages2"

// Role-wise (rms, messages, actor) => (peer) or peer that actor authenticated with is compromised
lemma auth_psk [reuse, use_induction, hide_lemma=posths_rms_weak]:
  "All tid tid2 actor actor2 role role2 peer peer2 rms messages aas #i #j #k.
    RRMS(tid, actor, role, <peer2,rms,messages>)@i & 
    RRMS(tid2, peer, role2, <actor2,rms,messages>)@j &
    CIdentity(tid, actor, role, <peer2,<aas,'auth'>>)@k &
    not (role = role2)
     ==>
      peer2 = peer |
      Ex #r. RevLtk(peer2)@r & #r < #k"

// Commited => Running?
// Can be found in the unify flow graph, but not sufficient to prove

// Action correspondence
lemma consistent_nonces [reuse]:
  "All tid actor role nonces #i. 
    CNonces(tid, actor, role, <nonces>)@i ==>
      Ex #j. RNonces(tid, actor, role, <nonces>)@j"

// Role & action correspondence
lemma matching_rms_nonces [reuse]:
  "All nonces tid tid2 actor actor2 peer peer2 rms messages #i #j. 
    RRMS(tid, actor, 'client', <peer,rms,messages>)@i &
    RRMS(tid2, actor2, 'server', <peer2,rms,messages>)@j &
    CNonces(tid2, actor2, 'server', <nonces>)@j ==>
      Ex #a.
        CNonces(tid, actor, 'client', <nonces>)@a & 
        #a < #i"

// Only constructible functions. Means that we have to prove that the function is never output - may be doable with AI?
// Taint analysis + function modelling - reveals need to be identified though

// Only constructible function (implies never Out?)
lemma ku_extract [reuse, use_induction]:
  "All a b #i. KU(Extract(a, b))@i ==> Ex #j #k. KU(a)@j & KU(b)@k & #j < #i & #k < #i"

// Unrolled version of ku_extract? (Attacker knows '0')
lemma ku_hs [reuse]:
  "All tid actor role es hs res_psk gxy #i #j.
    RHS(tid, actor, role, <hs>)@i &
    hs = Extract(gxy, es) &
    es = Extract(res_psk, '0') &
    KU(hs)@j ==>
      Ex #k #l. KU(gxy)@k & KU(res_psk)@l & #k < #j & #l < #j"

// Reveals need special handling. Could they be represented differently in models?

// Only constructible, unless a PSK reveal has happened
lemma ku_expand [reuse, use_induction]:
"All secret label len #i. KU(Expand(secret, label, len))@i ==>
  (Ex #j. KU(secret)@j & #j < #i) |
  (not (Ex #k. KU(secret)@k & #k < #i) &
  (Ex actor #l. RevealPSK(actor, Expand(secret, label, len))@l & #l < #i))"

// To learn g^xy, a reveal for x or y must have happened
lemma dh_chal_dual [reuse]:
  "All tid tid2 actor actor2 g x y gx gy gxy #i #j #r.
      DHChal(g, x, y, gx, gy, gxy)@i & Instance(tid, actor, 'client')@i &
      DHChal(g, x, y, gx, gy, gxy)@j & Instance(tid2, actor2, 'server')@j &
      KU(gxy)@r 
      ==> 
      (Ex #p. (RevDHExp(tid, actor,  x)@p & #p < #r)) | 
      (Ex #q. (RevDHExp(tid2, actor2, y)@q & #q < #r))"

// To learn ltkA, a Ltk reveal must have happened
lemma ku_ltk [reuse]:
  "All actor ltkA #i #j.
    GenLtk(actor, ltkA)@i & KU(ltkA)@j ==>
      Ex #k. RevLtk(actor)@k & #k < #j"

// To learn PSK, a PSK reveal must have happened
lemma ku_fresh_psk [reuse]:
  "All ticket res_psk #i #k.
      FreshPSK(ticket,res_psk)@i & KU(res_psk)@k ==> 
        Ex actor #j. 
          RevealPSK(actor, res_psk)@j & #j < #k"

// To learn rms, a reveal of either x, y, or a previous participants rms must have occurred
lemma matching_sessions [reuse, use_induction, hide_lemma=posths_rms]:
  "All tid tid2 actor actor2 role role2 peer peer2 rms messages #i #j #k.
    RRMS(tid, actor, role, <peer2,rms,messages>)@i & 
    RRMS(tid2, peer, role2, <actor2,rms,messages>)@j &
    not (role = role2) &
    KU(rms)@k ==>
      (Ex tid3 x #r. RevDHExp(tid3, actor, x)@r & #r < #i) |
      (Ex tid4 y #r. RevDHExp(tid4, peer, y)@r & #r < #j) |
      (Ex rms2 #r. RevealPSK(actor, rms2)@r & #r < #k) |
      (Ex rms2 #r. RevealPSK(peer, rms2)@r & #r < #k)"

// To learn a valid certificate signature, either the attacker must know the ltkA or the signature must have been generated in the protocol (weirdly specific?)
lemma sig_origin [reuse]:
  "All certificate certificate_request_context signature verify_data hs_key sig_messages ltkA  #i.
        KU(senc{<'11',certificate_request_context,certificate>, <'15',  signature >, <'20',verify_data>}hs_key)@i & (signature = sign{sig_messages}ltkA) ==>
      (Ex #j. KU(ltkA)@j & #j < i) | (Ex #k. UseLtk(ltkA, signature)@k & #k < #i)"

// Require precise structure for terms
lemma hsms_derive [reuse]:
  "All tid actor role hs ms #i. 
    RHSMS(tid, actor, role, <hs,ms>)@i ==>
      ms = Extract('0', hs)"

// For any RPostHS...(tid, , , <>) either the auth_status was set in the main HS and
// unchanged (along with the RMS), or there was post-hs auth, which means the
// peer's auth_status is 'auth', the actor is a server
lemma posths_rms [reuse, use_induction]:
  "All tid actor role hs rms peer auth_status messages #i. 
    RPostHS(tid, actor, role, <hs,rms,peer,auth_status,messages>)@i ==>
      Ex aas pas ms #j. 
                RRMS(tid, actor, role, <peer,rms,messages>)@j &
                ms = Extract('0', hs) & rms = Expand(ms, <'rms', <h(messages)>>, '32') & #j < #i &
                auth_status = <aas, pas> &
      (
        (Ex aas2 #k. CIdentity(tid, actor, role, <peer,<aas2,pas>>)@k & #k < #i) |
        (Ex aas2 #k. CIdentityPost(tid, actor, role, <peer,<aas2,pas>>)@k &
                role = 'server' & pas = 'auth' & (#k < #i | #k = #i)
        )
      )"

// A weakened version of the above lemma when needing to avoid the looping
// issue of the CIdentityPost(tid, ..., , <>) bit.
// Can use [hide_lemma=posths_rms] to only use this version.

// For any RPostHS...(tid, , , <>) either the auth_status was set in the main HS and
// unchanged (along with the RMS), or there was post-hs auth, which means the
// peer's auth_status is 'auth', the actor is a server
lemma posths_rms_weak [reuse, use_induction]:
  "All tid actor role hs rms peer auth_status messages #i. 
    RPostHS(tid, actor, role, <hs,rms,peer,auth_status,messages>)@i ==>
      Ex aas pas ms #j. 
                RRMS(tid, actor, role, <peer,rms,messages>)@j &
                ms = Extract('0', hs) & rms = Expand(ms, <'rms', <h(messages)>>, '32') & #j < #i &
                auth_status = <aas, pas>"

// 
lemma rms_derives_hs[reuse,hide_lemma=sig_origin]:
  "All tid actor role peer hs rms messages #i #j #k.
     RRMS(tid, actor, role, <peer,rms,messages>)@j &
     CHS(tid, actor, role, <hs>)@i &
     KU(rms)@k ==> 
         (Ex ms #l. 
             ms = Extract('0', hs) &
             KU(hs)@l & #l < #k) |
         (Ex #l. RevealPSK(actor, rms)@l & #l < #k) |
         (Ex #l. RevealPSK(peer, rms)@l & #l < #k)"

// 
lemma post_master_secret [reuse, hide_lemma=posths_rms]:
  "All tid actor peer role hs rms aas messages #i #k.
    RPostHS(tid, actor, role, <hs,rms,peer,<aas,'auth'>,messages>)@i & 
    CHS(tid, actor, role, <hs>)@i & 
    CIdentityPost(tid, actor, role, <peer,<aas,'auth'>>)@i &
    KU(rms)@k ==>
      (Ex #r. RevLtk(peer)@r & #r < #i) |
      (Ex tid3 x #r. RevDHExp(tid3, peer, x)@r & #r < #i) |
      (Ex tid4 y #r. RevDHExp(tid4, actor, y)@r & #r < #i) |
      (Ex rms2 #r. RevealPSK(actor, rms2)@r & #r < #k) |
      (Ex rms2 #r. RevealPSK(peer, rms2)@r & #r < #k)"

// To learn a hs, there must be a reveal
lemma handshake_secret [reuse, use_induction, hide_lemma=posths_rms_weak]:
  "All tid actor peer role hs aas #i #k.
    CHS(tid, actor, role, <hs>)@i &
    CIdentity(tid, actor, role, <peer,<aas,'auth'>>)@i &
    KU(hs)@k ==>
        (Ex #r. RevLtk(peer)@r & #r < #i) |
        (Ex tid3 x #r. RevDHExp(tid3, peer, x)@r & #r < #i) |
        (Ex tid4 y #r. RevDHExp(tid4, actor, y)@r & #r < #i) |
        (Ex rms #r. RevealPSK(actor, rms)@r & #r < #k) |
        (Ex rms #r. RevealPSK(peer, rms)@r & #r < #k)"

// To learn a hs outside of PSK key exchange mode, there must be a key reveal
lemma pfs_handshake_secret [reuse, hide_lemma=posths_rms_weak]:
  "All tid actor peer role hs aas psk_ke_mode #i #k.
    CHS(tid, actor, role, <hs>)@i &
    RMode(tid, actor, role, <psk_ke_mode>)@i &
    CIdentity(tid, actor, role, <peer,<aas,'auth'>>)@i &
    KU(hs)@k &
    (not psk_ke_mode = '0') ==>
        (Ex #r. RevLtk(peer)@r & #r < #i) |
        (Ex tid3 x #r. RevDHExp(tid3, peer, x)@r & #r < #i) |
        (Ex tid4 y #r. RevDHExp(tid4, actor, y)@r & #r < #i) |
        (Ex rms #r. RevealPSK(actor, rms)@r & #r < #i) |
        (Ex rms #r. RevealPSK(peer, rms)@r & #r < #i)"

// Security properties

/*
  Unilateral (entity) authentication
*/
lemma entity_authentication [reuse, use_induction]:
  "All tid actor peer nonces cas #i. 
      CNonces(tid, actor, 'client', <nonces>)@i & CIdentity(tid, actor, 'client', <peer,<cas,'auth'>>)@i &
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 x #r. RevDHExp(tid3, peer, x)@r & #r < #i) &
      not (Ex tid4 y #r. RevDHExp(tid4, actor, y)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
          ==> (Ex tid2 #j. RNonces(tid2, peer, 'server', <nonces>)@j & #j < #i)"

/*
  Integrity of handshake messages
*/
lemma transcript_agreement [reuse]:
  "All tid actor peer transcript cas #i.
      CTranscript(tid, actor, 'client', <transcript>)@i & CIdentity(tid, actor, 'client', <peer,<cas,'auth'>>)@i &
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 x #r. RevDHExp(tid3, peer, x)@r & #r < #i) &
      not (Ex tid4 y #r. RevDHExp(tid4, actor, y)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
          ==> (Ex tid2 #j. RTranscript(tid2, peer, 'server', <transcript>)@j & #j < #i)"

/*
  Mutual (entity) authentication
*/
lemma mutual_entity_authentication [reuse, use_induction]:
  "All tid actor peer nonces sas #i.
      CNonces(tid, actor, 'server', <nonces>)@i & CIdentity(tid, actor, 'server', <peer,<sas,'auth'>>)@i &
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 x #r. RevDHExp(tid3, peer, x)@r & #r < #i) &
      not (Ex tid4 y #r. RevDHExp(tid4, actor, y)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
          ==> (Ex tid2 #j. RNonces(tid2, peer, 'client', <nonces>)@j & #j < #i)"

/*
  Integrity of handshake messages
*/
lemma mutual_transcript_agreement [reuse]:
  "All tid actor transcript peer sas #i.
      CTranscript(tid, actor, 'server', <transcript>)@i & CIdentity(tid, actor, 'server', <peer,<sas,'auth'>>)@i & 
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 x #r. RevDHExp(tid3, peer, x)@r & #r < #i) &
      not (Ex tid4 y #r. RevDHExp(tid4, actor, y)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
          ==> (Ex tid2 #j. RTranscript(tid2, peer, 'client', <transcript>)@j & #j < #i)"

/*
  Mutual (entity) authentication
*/
lemma injective_mutual_entity_authentication [reuse, hide_lemma=posths_rms]:
  "All tid actor peer role nonces aas #i.
      CNonces(tid, actor, role, <nonces>)@i & CIdentity(tid, actor, role, <peer,<aas,'auth'>>)@i &
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 x #r. RevDHExp(tid3, peer, x)@r & #r < #i) &
      not (Ex tid4 y #r. RevDHExp(tid4, actor, y)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
          ==> 
          Ex role2 tid2 #j. RNonces(tid2, peer, role2, <nonces>)@j & #j < #i & not role = role2 &
          (All tid3 peer2 #k. RNonces(tid3, peer2, role2, <nonces>)@k ==> #k = #j)"

// To reveal a DH exp x for a (tid, actor), x must have been generated by (tid, actor)
lemma dh_exp_invariant  [use_induction, reuse]:
  "All tid actor x #i. RevDHExp(tid, actor, x)@i ==>
    Ex #j. DH(tid, actor, x)@j & #j < i"

// Delete comes after DH, and all RevDH must occur between
lemma rev_dh_ordering  [reuse, use_induction]:
  "All tid actor x #j. 
    DeleteDH(tid, actor, x)@j==>
      ((Ex #i. DH(tid, actor, x) @ i & i < j) & 
       (All #r. RevDHExp(tid, actor, x) @ r  ==>  r < j))"

end
